#Socket && Netty测试说明
>本文档用于介绍Socket网络原理，及netty这种nio的网络通信实现方式。包括ipc、Rpc、以及hadoop、spark中相关原理的使用。

##目录
* 网络基础
* linux下网络相关的探索
* socket使用
* netty使用
---
## 网络基础
一般我们将网络分为物理层、数据链路层、网络层、传输层、应用层。

物理层：计算机中的信息其实就是0和1，表现在物理层面其实就是高低电平。比如5V电压表示高电平，0V或者1V相对而言就是低电平。

数据链路层：一堆0和1组成的数据是需要编码切割为我们认识的数据，所以这里引入相关数据切割的标准，将0和1组成的数据块分为Head和Data两块，Head部分固定18个Byte（包含发送方和接收方的mac地址等），Data部分46~1500Byte。
（所以其实一般大文件的传输，肯定是要拆分为多个package来进行传输的）
局域网内部的通信，其实就是依靠mac地址，通过广播的方式获取的（ARP协议）

网络层：上面的数据链路层只能解决局域网少数节点的通信，受限于“广播机制”的局限性，需要引入新的发现机制，引入网络层。类似于网络中社团的概念，一个社团就是一个局域网。不同社团之间的网络发现需要引入“网关、IP、子网掩码”等概念。
这就是所谓的网络层。这里的ARP（地址解析协议）协议也升级了，需要进一步实现ip和mac地址之间的映射。

那么互联网中的两个ip是如何找到彼此的呢？
首先IP1先判断IP2和自己是不是同一局域网网段，如果不是的话进一步去路由表中找到网关的mac地址，然后定向广播到这个网关对应的局域网中的机器，获取到ip2的mac地址后进一步缓存下来，整个过程可以用wireshark来进一步观察。

传输层：上面都是说的机器之间如何通信，那么更细的粒度，机器内部的进程之间是如何进行通信的呢？答案就在传输层这里，这里使用的是TCP、UDP协议等。
通过使用端口的方式来进行网络数据的传输。
TCP协议的报文：分为TCP头部和TCP数据部分。头部包含源端口号、目标端口号、ACK标识等。

TCP的整个链路过程（三次握手和四次挥手）：
三次握手：
1、客户端发送SYN包（syn=1）和随机的seq序号值给服务器，并进入SYN_SENT状态；
2、服务器收到SYN包，并确认ack=seq+1，然后也发送一个SYN包（syn=1）和一个随机的seq给到客户端，进入SYN_RECV状态；
3、客户端收到服务端的SYN+ACK包，并向服务器发送确认包ACK（ack=seq+1），并进入ESTABLISHED状态，表示TCP连接成功；
至此连接一直保持，除非一方释放连接才会触发挥手操作。

四次挥手：
1、第一次挥手，客户端进程发出释放连接的报文，FIN=1、seq=u（之前传输数据的最后一个字节的序号+1）
，此时客户端进入FIN_WAIT_1（终止等待1）状态。
2、第二次挥手，服务器收到连接释放的报文，然后发出确认报文给客户端，ACK=1，ack=u+1，并带上序列号seq=v,到这里服务器端口状态进入CLOSE_WAIT（关闭等待）状态。
这时候属于半关闭状态，客户端不能发送数据给服务端了，但是服务端可以发送数据给客户端。这个时候客户端端口的状态为FIN_WAIT_2（终止等待2）状态。
3、第三次挥手，服务器将最后的数据发送完毕，然后发送FIN=1，ack=u+1，进入LASK_ACK（最后确认状态）
4、客户端收到服务器的连接释放报文后，发出确认信号，ack=w+1,seq=u+1,此时客户端端口就进入TIME_WAIT（时间等待）状态，经过2*MSL最长报文段寿命的时间才会进入CLOSED状态。
服务端是一收到客户端的确认就会直接进入CLOSE状态。

至此，整个tcp连接过程结束！！！
![image](.\微信图片_20200727145454.jpg)



##Linux下网络相关的探索
1、使用tcpdump+wireshark进行报文分析
这里以namenode的端口8020为例：
tcpdump -i ens32 -w /home/testtcpdump host linu-4-29 and port 8020
然后使用wireshark打开testtcpdump文件分析，其中Ethernet中的内容就是数据链路层和网络层相关的信息。






